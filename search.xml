<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA['MySQL']]></title>
    <url>%2F2020%2F03%2F01%2FMySQL.html</url>
    <content type="text"><![CDATA[MySQL登录​ 假如我用户名为root，密码为123456 1mysql -u root -p 123456 -h 127.0.0.1 ​ -h 参数为要连接的主机 库级操作​ 显示数据库: show databases; ​ 选择数据库: use dbname; ​ 创建数据库: create database dbname charset utf8; ​ 删除数据库: drop database dbname; 表级操作​ 首先得用use dbname进入一个数据库； ​ 显示库下面的表：show tables; ​ 查看表的结构：desc tableName; ​ 查看表的创建过程：show create table tableName 创建表1234create table tbName (列名称1 列类型 [列参数] [not null default ],列名称N 列类型 [列参数] [not null default ]) engine myisam/innodb charset utf8/gbk ​ 修改表123456789101112131415161718#增添列alter table tableName add 列名 列类型 [列参数] [not null default ];#修改列alter table tableName change 旧列名 新列名 列类型 [列参数] [not null default ];#删除列alter table tableName drop 列名;#增加主键alter table tableName add primary key(主键所在列名);#删除主键alter table tableName drop primary key;#增加索引alter table tableName add [unique|fulltext] index 索引名(列名);#删除索引alter table tableName drop index 索引名;#清空表的数据truncate tableName; 数据类型​ 这里只列出常用的：int，float ，double，char（定长字符），varchar（变长字符），timestamp 数据级操作12345678910#增insert into 表名(col1,col2,……) values(val1,val2……);#若默认按序插入全部列可简写如下insert into 表名 values(val1,val2……);#一次性插入多条数据insert into 表名 values(val1,val2……),(val1,val2……),(val1,val2……);#改update tableName set colName=newVal where 条件;#删delete from tableName where 条件; 查​ 查询全部列 1select * from tableName; ​ 查询指定列 1select col1,col2...coln from tableName; ​ 常用关键字 ​ DISTINCT：返回惟一的值（去重） 1select DISTINCT colName from tableName where 条件; ​ LIMIT：限制返回的结果条数 1234#对查询结果返回前n条数据select * from tableName LIMIT n;#对查询结果从第n行开始，取n条数据作为返回结果select * from tableName LIMIT n,n; ​ ORDER BY colName DESC/ASC：对返回结果按指定的列名进行排序（降序/升序） 1select * from tableName ORDER BY colName DESC; ​ 查找最大或最小 1select * from tableName ORDER BY colName DESC/ASC LIMIT 1 分组查询 group by​ What？将查询结果按照1个或多个字段进行分组，字段值相同的为一组，即按照某一列进行分类。 ​ 现有一张学生表如下： ​ ​ group_concat()函数 12#将age,name分组,查询每个学生的姓名并成一组的形式返回select age,group_concat(name) from students group by age; ​ 查询结果为： ​ ​ GROUP BY + 聚合函数 12#按年龄字段查询学生人数select age,count(*) from students group by age; ​ 查询结果为： ​ ​ ​ group by + having 1234#用来分组查询后制定一些条件来输出查询结果#having的作用和where一样，但having只能用于group by#查询符合年龄要求的学生（此处只是为了演示。。）select age,group_concat(name) from students group by(age) having age&gt;20; ​ 查询结果为： ​ 在这里做一下 总结 ： ​ 连接查询 12#左连接;右连接类似(right join);内连接(inner join)，取的是左右连接的交集table A left join table B on tableA.col1 = tableB.col2; ​ 子查询 12select * from tableA where colA = (select colB from tableB where ...);select * from (select * from ...) as tableName where .... 事务（Transaction）​ 定义：一个最小的不可再分的工作单元； 四大特性(ACID)：​ 1、原子性(Actomicity)：事务是最小单位，不可再分 ​ 2、一致性(Consistency)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败 ​ 3、隔离性(Isolation)：事务A和事务B之间具有隔离性 ​ 4、持久性(Durability)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中) ​ ​ 事务成功执行，则提交；若失败，则回滚； 123456#开启事务start transaction#执行SQL语句insert、update、delete ...#提交事务，若失败内部会执行&apos;rollback;&apos;进行回滚，则不会修改底层数据。commit; 隔离级别1234567891011121314151617181920211、读未提交：read uncommitted- 事物A和事物B，事物A未提交的数据，事物B可以读取到- 这里读取到的数据叫做“脏数据”- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别2、读已提交：read committed- 对方事物提交之后的数据，我当前事物才能读取到- 这种隔离级别高于读未提交- 这种级别可以避免“脏数据”，但会导致“不可重复读取”- Oracle默认隔离级别3、可重复读：repeatable read- 对方提交之后的数据，我还是读取不到- 这种隔离级别高于读已提交- 这种隔离级别可以避免“不可重复读取”，达到可重复读取，但是会导致“幻读”- MySQL默认级别4、串行化：serializable- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待- 这种隔离级别很少使用，吞吐量太低，用户体验差- 这种级别可以避免“幻读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发 ​ 隔离级别与一致性的关系如下表： ​ 设置隔离级别： 1234#方式1、在my.ini文件中使用transaction-isolation选项来设置服务器的缺省事务隔离级别transaction-isolation = READ-COMMITTED#方式2、通过命令在运行的服务器中动态设置隔离级别SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; ​ 设置隔离级别的作用范围： 1234567#会话级：只对当前的会话有效 SET TRANSACTION ISOLATION LEVEL READ COMMITTED;#或SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;#全局级：对所有的会话有效 SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED; ​ 查看隔离级别 1SELECT @@tx_isolation 触发器​ 即在修改表（增、删、改）时触发相应的SQL语句。注： 不能用在临时表和视图上，尽量少使用触发器，不建议使用，因为它十分消耗资源 123456789#创建触发器create trigger triggerNameafter/before insert/delete/update on tableNamefor each rowsql; #触发SQL语句#删除触发器drop trigger triggerName; 索引​ 提高查询速度,但是 降低 了增删改的速度，所以使用索引时,要综合考虑，索引不是越多越好，一般我们在经常出现于条件表达式中的列加索引，值越分散的列，索引的效果越好。 ​ 索引类型：primary key主键索引、index 普通索引、unique index 唯一性索引、fulltext index 全文索引 ​ 在这儿再贴上之前提过的创建和删除语句： 1234#增加索引alter table tableName add [unique|fulltext] index 索引名(列名);#删除索引alter table tableName drop index 索引名; 参考文章： mysql：https://blog.poetries.top/2019/01/22/mysql-base-review/ 分组查询：https://zhuanlan.zhihu.com/p/46925457 事务：https://blog.csdn.net/w_linux/article/details/79666086 触发器：https://www.cnblogs.com/geaozhang/p/6819648.html 索引：https://zhuanlan.zhihu.com/p/29118331]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['2017-EMNLP-Deep Joint Entity Disambiguation with Local Neural Attention']]></title>
    <url>%2F2020%2F02%2F26%2FAttention.html</url>
    <content type="text"><![CDATA[Abstract​ 我们提出了一种新的文档级别联合实体消歧的深度学习模型，关键部分有实体嵌入、基于上下文窗格的神经注意力机制和a differentiable joint inference stage for disambiguation 。我们的方法因而结合了深度学习和大多数传统方法（如图模型和概率图等等）的优点。实验显示在适度的计算代价内我们能够获得stateof-the-art 的准确率。 1 Introduction​ 实体消歧（ED）在给出的知识库（KB ）中解决了涉及到的实体问题，是文本理解的一个重要阶段，ED任务因为内在含义的模糊性（如实体名和实体本身代表的含义）而极具挑战力。这种多对多的不确定能够被从实体链接语料库中提取出的name-entity co-occurrence counts 部分捕获。 ​ ED的研究大部分专注于两种文本信息的消歧：一是局部信息，只是这些实体提到的文本上下文窗格大小范围内的词；而全局信息，是开发相关实体的文档 coherence ，很多stateof-the-art 的方法旨在结合这两者的好处，而这也是我们所遵守的哲理。我们方法的特殊之处在于我们用实体嵌入做了通用表现来同时评估局部和全局。 ​ 这些年，很多文本和语言理解任务都是利用神经网络架构进行升级。然而，尽管是在最近的工作中，有竞争性的ED系统仍然大量地使用了人工设计的特征。这些特征总是依赖于领域知识，而且很多统计相关的依赖关系和相互作用是失败的。我们的工作有一个明确的目标，就是利用深度学习从scratch 中学习基本特征和它们的组合。穷尽我们的知识，伴随严苛，我们第一个采取了这个计划。 2 Contributions and Related Work​ 之前在实体消歧方面就有大量的研究，尤其是(Ji, 2016 Entity discovery and linking reading list. ) ，我们将在这里讨论之前相关研究工作中的主要贡献。 Entity Embeddings.​ 我们在向量空间中已经发现了一种简单却高效的方法来做实体嵌入和词嵌入。这是鉴于词嵌入e.g. (Mikolov et al., 2013; Pennington et al.,2014)， 后来被拓展到实体嵌入和ED(Yamada et al., 2016; Fang et al., 2016;Zwicklbauer et al., 2016; Huang et al., 2015) 。和上面的方法需求数据的entity-entity co-occurrences 通常都很稀疏不同，我们宁可提升词嵌入从它们的典型实体页面和它们的超链接注释的局部上下文。这让训练更高效而且减轻了compile co-linking statistics 的需求。这些向量表现是避免手工设计特征、多重的消歧步骤、ED任务中对额外启发式算法的需求的关键。 Context Attention.​ 我们为局部ED提出了一种新的注意力机制。受记忆网络(Sukhbaatar et al., 2015) 和(Lazic et al.,2015) 的启发，我们的模型部署了注意力机制来选择那些对消歧提供有用信息的词语。是一个结合了情境实体分数和记忆实体最终分数的学习。我们的局部模型获得了更好的精确率相比于局部概率模型(Ganeaet al., 2016) 和基于特征工程的局部模型(Globerson et al., 2016)。作为新特点，我们的模型拥有更小的内存占用并且能快速完成训练和测试。 ​ ​ 未完待续。。。。]]></content>
      <categories>
        <category>Translates</category>
      </categories>
      <tags>
        <tag>translating</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['Cypher']]></title>
    <url>%2F2020%2F02%2F24%2FCypher.html</url>
    <content type="text"><![CDATA[Cypher​ 一种 Neo4j 的查询语言，她是根据查询的路径来进行编写。 ​ 举栗子：a Person LIVES_IN a City or a City is PART_OF a Country. 1(:Person) -[:LIVES_IN]-&gt; (:City) -[:PART_OF]-&gt; (:Country) node syntax () 代表任何节点，包罗万象。 123456() (matrix)(:Movie)(matrix:Movie)(matrix:Movie &#123;title: &quot;The Matrix&quot;&#125;)(matrix:Movie &#123;title: &quot;The Matrix&quot;, released: 1997&#125;) relationship syntax12345--&gt;-[role]-&gt;-[:ACTED_IN]-&gt;-[role:ACTED_IN]-&gt;-[role:ACTED_IN &#123;roles: [&quot;Neo&quot;]&#125;]-&gt; pattern syntax123(keanu:Person:Actor &#123;name: &quot;Keanu Reeves&quot;&#125; )-[role:ACTED_IN &#123;roles: [&quot;Neo&quot;] &#125; ]-&gt;(matrix:Movie &#123;title: &quot;The Matrix&quot;&#125; ) ‘ : ‘之前的均为变量，为了方便在别的地方进行引用， 当然，变量也可以用来表示一条路径 1acted_in = (:Person)-[:ACTED_IN]-&gt;(:Movie) 路径也有一些属性，如节点数，关系数和路径长度，nodes(path), relationships(path) ,length(path). clauses​ CREATE ONE 1CREATE (:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;) ​ CREATE MORE 1234CREATE (a:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)-[r:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(m:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)CREATE (d:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)-[:DIRECTED]-&gt;(m)RETURN a,d,r,m MATCH 12MATCH (m:Movie)RETURN m 12MATCH (p:Person &#123; name:&quot;Keanu Reeves&quot; &#125;)RETURN p 12MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)-[r:ACTED_IN]-&gt;(m:Movie)RETURN m.title, r.roles 1234MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)CREATE (m:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)CREATE (p)-[r:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(m)RETURN p,r,m MERGE（MATCH+CREATE） 先判断需要玩弄的东西在数据库中是否存在，再进行相应的操作 123MERGE (m:Movie &#123; title:&quot;Cloud Atlas&quot; &#125;)ON CREATE SET m.released = 2012RETURN m 12345MATCH (m:Movie &#123; title:&quot;Cloud Atlas&quot; &#125;)MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)MERGE (p)-[r:ACTED_IN]-&gt;(m)ON CREATE SET r.roles =[&apos;Zachry&apos;]RETURN p,r,m 如果没有满足MERGE之后描述的关系，就执行相应的操作（创建一个2014Year） 1234CREATE (y:Year &#123; year:2014 &#125;)MERGE (y)&lt;-[:IN_YEAR]-(m10:Month &#123; month:10 &#125;)MERGE (y)&lt;-[:IN_YEAR]-(m11:Month &#123; month:11 &#125;)RETURN y,m10,m11 Getting the correct results 一个官方实例，首先创建用于练习的图。该图包含电影和人物节点，参演（属性有角色roles，即参演的演员）和指导关系。 123456789CREATE (matrix:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)CREATE (cloudAtlas:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)CREATE (forrestGump:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)CREATE (keanu:Person &#123; name:&quot;Keanu Reeves&quot;, born:1964 &#125;)CREATE (robert:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)CREATE (tom:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)CREATE (tom)-[:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(forrestGump)CREATE (tom)-[:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(cloudAtlas)CREATE (robert)-[:DIRECTED]-&gt;(forrestGump) 查找标题为”The Matrix”的电影 123MATCH (m:Movie)WHERE m.title = &quot;The Matrix&quot;RETURN m 上条查询语句也可以直接写成如下： 12MATCH (m:Movie &#123; title: &quot;The Matrix&quot; &#125;)RETURN m Cypher中 ‘ =~ ‘ 表示进行正则匹配 查询 p-r-&gt;m，人物名字为’k’开头 or 电影在2000年后发行 or 参演的角色中包含 “Neo”，返回满足以上条件的 p,r,m 123MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)WHERE p.name =~ &quot;K.+&quot; OR m.released &gt; 2000 OR &quot;Neo&quot; IN r.rolesRETURN p,r,m 查询p-&gt;m 且 p 没有指导任何电影，返回p,m 123MATCH (p:Person)-[:ACTED_IN]-&gt;(m)WHERE NOT (p)-[:DIRECTED]-&gt;()RETURN p,m 上述例子都是直接返回变量，接下来看看返回numbers, strings, arrays，maps 的情况。 ‘ coalesce() ’ 返回第一个非空值，当所有的都为空时，则返回null, 下例中则表示若p没有昵称则直接返回”n/a”，更一般的，对于coalesce(a,b)，若a , b均为空值，则返回null。 ‘ AS ‘ 表示 为一个东西起别名，是返回的表中的列名。 123MATCH (p:Person)RETURN p, p.name AS name, toUpper(p.name), coalesce(p.nickname,&quot;n/a&quot;) AS nickname, &#123; name: p.name, label:head(labels(p))&#125; AS person ‘ DISTINCT ‘ ，用于去重，即返回唯一值。 12MATCH (n)RETURN DISTINCT labels(n) AS Labels 返回总人数。 12MATCH (:Person)RETURN count(*) AS people Cypher也支持聚集函数，如count, sum, avg, min, max 返回 共同满足 参演关系和指导关系的人物和总数 12MATCH (actor:Person)-[:ACTED_IN]-&gt;(movie:Movie)&lt;-[:DIRECTED]-(director:Person)RETURN actor, director, count(*) AS collaborations 对结果进行排序，分页 SKIP {offset}、 LIMIT {count} 123MATCH (a:Person)-[:ACTED_IN]-&gt;(m:Movie)RETURN a, count(*) AS appearancesORDER BY appearances DESC LIMIT 10; ‘ collect() ‘把返回的多个值或记录组装成一个列表 12MATCH (m:Movie)&lt;-[:ACTED_IN]-(a:Person)RETURN m.title AS movie, collect(a.name) AS cast, count(*) AS actors ‘ UNWIND ‘ 拆解collect 12UNWIND[1,2,3] AS xRETURN x Composing large statements 使用的例子图： 123456789CREATE (matrix:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)CREATE (cloudAtlas:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)CREATE (forrestGump:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)CREATE (keanu:Person &#123; name:&quot;Keanu Reeves&quot;, born:1964 &#125;)CREATE (robert:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)CREATE (tom:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)CREATE (tom)-[:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(forrestGump)CREATE (tom)-[:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(cloudAtlas)CREATE (robert)-[:DIRECTED]-&gt;(forrestGump) UNION 对于相似的查询结构，取结果的并集。 12345MATCH (actor:Person)-[r:ACTED_IN]-&gt;(movie:Movie)RETURN actor.name AS name, type(r) AS type, movie.title AS titleUNIONMATCH (director:Person)-[r:DIRECTED]-&gt;(movie:Movie)RETURN director.name AS name, type(r) AS type, movie.title AS title 以上语句等同于： 12MATCH (actor:Person)-[r:ACTED_IN|DIRECTED]-&gt;(movie:Movie)RETURN actor.name AS name, type(r) AS type, movie.title AS title WITH 引导数据的流向，和 RETURN 相似只是不会终止查询。 1234MATCH (person:Person)-[:ACTED_IN]-&gt;(m:Movie)WITH person, count(*) AS appearances, collect(m.title) AS moviesWHERE appearances &gt; 1RETURN person.name, appearances, movies Defining a schema 例子图： 123456789CREATE (matrix:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)CREATE (cloudAtlas:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)CREATE (forrestGump:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)CREATE (keanu:Person &#123; name:&quot;Keanu Reeves&quot;&#125;)CREATE (robert:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)CREATE (tom:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)CREATE (tom)-[:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(forrestGump)CREATE (tom)-[:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(cloudAtlas)CREATE (robert)-[:DIRECTED]-&gt;(forrestGump) INDEX 创建索引，这样在查询的时候会加快查询速度。 1CREATE INDEX ON :Actor(name) 查看数据库中的索引。 12CALL db.indexesYIELD description, tokenNames, properties, type; CONSTRAINT 为数据添加需要遵守的相关规则 1CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE 查看constraints。 1CALL db.constraints Import data 我们要导入movies.csv，roles.csv，persons.csv三个文件到图数据库中。假如文件都使用file:/// URL。 1、首先为我们的电影和人物的ID创建唯一约束，为城市名创建索引就隐含了唯一的条件 1CREATE CONSTRAINT ON (person:Person) ASSERT person.id IS UNIQUE 1CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.id IS UNIQUE 1CREATE INDEX ON :Country(name) 2、然后我们将文件加载进来 12LOAD CSV WITH HEADERS FROM &quot;file:///persons.csv&quot; AS csvLineCREATE (p:Person &#123;id: toInteger(csvLine.id), name: csvLine.name&#125;) 1234LOAD CSV WITH HEADERS FROM &quot;file:///movies.csv&quot; AS csvLineMERGE (country:Country &#123;name: csvLine.country&#125;)CREATE (movie:Movie &#123;id: toInteger(csvLine.id), title: csvLine.title, year:toInteger(csvLine.year)&#125;)CREATE (movie)-[:MADE_IN]-&gt;(country) 1234USING PERIODIC COMMIT 500 //大文件进行分批导入，默认1000行提交一次，这里设置为500行提交一次LOAD CSV WITH HEADERS FROM &quot;file:///roles.csv&quot; AS csvLineMATCH (person:Person &#123;id: toInteger(csvLine.personId)&#125;),(movie:Movie &#123;id: toInteger(csvLine.movieId)&#125;)CREATE (person)-[:PLAYED &#123;role: csvLine.role&#125;]-&gt;(movie) 3、最后删除我们创建的唯一约束 小伙伴疑惑了，为什么要删除呢？因为ID的目的仅仅是为了便于导入关系的，最后我们当然可以进行删除啦。 1DROP CONSTRAINT ON (person:Person) ASSERT person.id IS UNIQUE 1DROP CONSTRAINT ON (movie:Movie) ASSERT movie.id IS UNIQUE 参考文档： https://neo4j.com/docs/getting-started/current/cypher-intro/results/]]></content>
      <categories>
        <category>Neo4j</category>
      </categories>
      <tags>
        <tag>cypher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['初识Neo4j']]></title>
    <url>%2F2020%2F02%2F23%2F%E5%88%9D%E8%AF%86Neo4j.html</url>
    <content type="text"><![CDATA[Neo4j‘s GOOD 完整的ACID支持（保证了数据的一致性） 高可用性 可以非常轻松地集成到任何一个应用，只会受到计算机本身硬件性能的影响，而不会不受业务本身的约束。 轻易扩展到上亿级别的节点和关系 通过遍历工具高速检索数据 WHAT 图数据库?​ 1、图数据库用图来存储数据，是最接近高性能的一种用于存储数据的数据结构方式之一。 ​ 2、一个图由无数的节点和关系组成，关系将图各个部分组织起来。如： 小黄拥有小韩，小韩喜欢小猪，这只小猪它是粉红色的（你知道吗小黄会嫉妒这只小猪的 …），粉红色就是这只猪的属性了。 ​ 3、用 Traversal 进行数据库查询，通过一种算法（宽度优先或深度优先），从一些开始节点开始查询与其关联的节点，经过一条路径最终找到结果。小黄—&gt;小韩—&gt;小猪 ​ 4、为节点和关系建立索引，这样可以更高效地进行查询。如： 我要查询的人名字叫 韩小沐（敲黑板，故事发展的重要人物。） ​ ​ 5、标签，为了便于进行特定的操作。如为小韩贴上 nicer 标签，就能更方便的使用，一个实体可以贴上多个标签，可以再给小韩贴上 student 标签，这样她就不可以恋爱啦，哈哈。 ​ 最后让我们来看一下推荐的节点，关系，属性命名规则吧： ​ 节点： :VehicleOwner rather than :vehice_owner ​ 关系： :OWNS_VEHICLE rather than :ownsVehicle ​ 属性： firstName rather than first_name]]></content>
      <categories>
        <category>Neo4j</category>
      </categories>
      <tags>
        <tag>neo4j</tag>
      </tags>
  </entry>
</search>
