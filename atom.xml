<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cherry&#39;Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ipyker.com/"/>
  <updated>2020-03-01T01:39:47.079Z</updated>
  <id>https://www.ipyker.com/</id>
  
  <author>
    <name>丨韦木丨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&#39;MySQL&#39;</title>
    <link href="https://www.ipyker.com/2020/03/01/MySQL.html"/>
    <id>https://www.ipyker.com/2020/03/01/MySQL.html</id>
    <published>2020-03-01T01:27:43.000Z</published>
    <updated>2020-03-01T01:39:47.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>​    假如我用户名为root，密码为123456</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 123456 -h 127.0.0.1</span><br></pre></td></tr></table></figure><p>​    -h 参数为要连接的主机</p><h4 id="库级操作"><a href="#库级操作" class="headerlink" title="库级操作"></a>库级操作</h4><p>​    显示数据库: <code>show databases;</code></p><p>​    选择数据库: <code>use dbname;</code></p><p>​    创建数据库: <code>create database dbname charset utf8;</code></p><p>​    删除数据库: <code>drop database dbname;</code></p><h4 id="表级操作"><a href="#表级操作" class="headerlink" title="表级操作"></a>表级操作</h4><p>​    首先得用<code>use dbname</code>进入一个数据库；</p><p>​    显示库下面的表：<code>show tables;</code></p><p>​    查看表的结构：<code>desc tableName;</code></p><p>​    查看表的创建过程：<code>show create table tableName</code></p><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table tbName (</span><br><span class="line">列名称1　列类型　[列参数]　[not null default ],</span><br><span class="line">列名称N　列类型　[列参数]　[not null default ]</span><br><span class="line">) engine myisam/innodb charset utf8/gbk</span><br></pre></td></tr></table></figure><p>​    </p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#增添列</span><br><span class="line">alter table tableName add 列名　列类型　[列参数]　[not null default ];</span><br><span class="line">#修改列</span><br><span class="line">alter table tableName change 旧列名  新列名  列类型　[列参数]　[not null default ];</span><br><span class="line">#删除列</span><br><span class="line">alter table tableName drop 列名;</span><br><span class="line"></span><br><span class="line">#增加主键</span><br><span class="line">alter table tableName add primary key(主键所在列名);</span><br><span class="line">#删除主键</span><br><span class="line">alter table tableName　drop primary key;</span><br><span class="line">#增加索引</span><br><span class="line">alter table tableName add [unique|fulltext] index 索引名(列名);</span><br><span class="line">#删除索引</span><br><span class="line">alter table tableName drop index 索引名;</span><br><span class="line"></span><br><span class="line">#清空表的数据</span><br><span class="line">truncate tableName;</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>​    这里只列出常用的：<code>int</code>，<code>float</code> ，<code>double</code>，<code>char</code>（定长字符），<code>varchar</code>（变长字符），<code>timestamp</code></p><h4 id="数据级操作"><a href="#数据级操作" class="headerlink" title="数据级操作"></a>数据级操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#增</span><br><span class="line">insert into 表名(col1,col2,……) values(val1,val2……);</span><br><span class="line">#若默认按序插入全部列可简写如下</span><br><span class="line">insert into 表名 values(val1,val2……);</span><br><span class="line">#一次性插入多条数据</span><br><span class="line">insert into 表名 values(val1,val2……),(val1,val2……),(val1,val2……);</span><br><span class="line">#改</span><br><span class="line">update tableName set colName=newVal where 条件;</span><br><span class="line">#删</span><br><span class="line">delete from tableName where 条件;</span><br></pre></td></tr></table></figure><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><p>​        查询全部列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tableName;</span><br></pre></td></tr></table></figure><p>​        查询指定列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1,col2...coln from tableName;</span><br></pre></td></tr></table></figure><p>​        常用关键字</p><p>​        <code>DISTINCT</code>：返回惟一的值（去重）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select DISTINCT colName from tableName where 条件;</span><br></pre></td></tr></table></figure><p>​        <code>LIMIT</code>：限制返回的结果条数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#对查询结果返回前n条数据</span><br><span class="line">select * from tableName LIMIT n;</span><br><span class="line">#对查询结果从第n行开始，取n条数据作为返回结果</span><br><span class="line">select * from tableName LIMIT n,n;</span><br></pre></td></tr></table></figure><p>​        <code>ORDER BY colName DESC/ASC</code>：对返回结果按指定的列名进行排序（降序/升序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tableName ORDER BY colName DESC;</span><br></pre></td></tr></table></figure><p>​        查找最大或最小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tableName ORDER BY colName DESC/ASC LIMIT 1</span><br></pre></td></tr></table></figure><h5 id="分组查询-group-by"><a href="#分组查询-group-by" class="headerlink" title="分组查询 group by"></a>分组查询 <code>group by</code></h5><p>​        What？将查询结果按照1个或多个字段进行分组，字段值相同的为一组，即按照某一列进行分类。</p><p>​        现有一张学生表如下：</p><p>​        <img src="https://pic.downk.cc/item/5e5a482c6127cc07134fc10d.png" alt></p><p>​        <strong>group_concat()</strong>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将age,name分组,查询每个学生的姓名并成一组的形式返回</span><br><span class="line">select age,group_concat(name) from students group by age;</span><br></pre></td></tr></table></figure><p>​        查询结果为：</p><p>​        <img src="https://pic.downk.cc/item/5e5a45ee6127cc07134f7755.png" alt></p><p>​        <strong>GROUP BY + 聚合函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#按年龄字段查询学生人数</span><br><span class="line">select age,count(*) from students group by age;</span><br></pre></td></tr></table></figure><p>​        查询结果为：</p><p>​        <img src="https://pic.downk.cc/item/5e5a478e6127cc07134fb011.png" alt></p><p>​        </p><p>​        <strong>group by + having</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用来分组查询后制定一些条件来输出查询结果</span><br><span class="line">#having的作用和where一样，但having只能用于group by</span><br><span class="line">#查询符合年龄要求的学生（此处只是为了演示。。）</span><br><span class="line">select age,group_concat(name) from students group by(age) having age&gt;20;</span><br></pre></td></tr></table></figure><p>​        查询结果为：        <img src="https://pic.downk.cc/item/5e5a499c6127cc07134ffa34.png" alt></p><p>​        在这里做一下 <strong>总结</strong> ：    <img src="https://pic.downk.cc/item/5e5a4be66127cc07135051a7.png" alt></p><p>​        连接查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#左连接;右连接类似(right join);内连接(inner join)，取的是左右连接的交集</span><br><span class="line">table A left join table B on tableA.col1 = tableB.col2;</span><br></pre></td></tr></table></figure><p>​        子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tableA where colA = (select colB from tableB where ...);</span><br><span class="line">select * from (select * from ...) as tableName where ....</span><br></pre></td></tr></table></figure><h4 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h4><p>​    定义：一个最小的不可再分的工作单元；</p><h5 id="四大特性-ACID-："><a href="#四大特性-ACID-：" class="headerlink" title="四大特性(ACID)："></a>四大特性(<strong>ACID</strong>)：</h5><p>​        1、原子性(Actomicity)：事务是最小单位，不可再分</p><p>​        2、一致性(Consistency)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败</p><p>​        3、隔离性(Isolation)：事务A和事务B之间具有隔离性</p><p>​        4、持久性(Durability)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)</p><p>​    </p><p>​    事务成功执行，则提交；若失败，则回滚；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">start transaction</span><br><span class="line">#执行SQL语句</span><br><span class="line">insert、update、delete ...</span><br><span class="line">#提交事务，若失败内部会执行&apos;rollback;&apos;进行回滚，则不会修改底层数据。</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、读未提交：read uncommitted</span><br><span class="line">- 事物A和事物B，事物A未提交的数据，事物B可以读取到</span><br><span class="line">- 这里读取到的数据叫做“脏数据”</span><br><span class="line">- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别</span><br><span class="line"></span><br><span class="line">2、读已提交：read committed</span><br><span class="line">- 对方事物提交之后的数据，我当前事物才能读取到</span><br><span class="line">- 这种隔离级别高于读未提交</span><br><span class="line">- 这种级别可以避免“脏数据”，但会导致“不可重复读取”</span><br><span class="line">- Oracle默认隔离级别</span><br><span class="line"></span><br><span class="line">3、可重复读：repeatable read</span><br><span class="line">- 对方提交之后的数据，我还是读取不到</span><br><span class="line">- 这种隔离级别高于读已提交</span><br><span class="line">- 这种隔离级别可以避免“不可重复读取”，达到可重复读取，但是会导致“幻读”</span><br><span class="line">- MySQL默认级别</span><br><span class="line"></span><br><span class="line">4、串行化：serializable</span><br><span class="line">- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待</span><br><span class="line">- 这种隔离级别很少使用，吞吐量太低，用户体验差</span><br><span class="line">- 这种级别可以避免“幻读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发</span><br></pre></td></tr></table></figure><p>​    隔离级别与一致性的关系如下表：</p><p><img src="https://pic.downk.cc/item/5e5a55c76127cc071351ab3d.png" alt></p><p>​    设置隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#方式1、在my.ini文件中使用transaction-isolation选项来设置服务器的缺省事务隔离级别</span><br><span class="line">transaction-isolation = READ-COMMITTED</span><br><span class="line">#方式2、通过命令在运行的服务器中动态设置隔离级别</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure><p>​    设置隔离级别的作用范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#会话级：只对当前的会话有效 </span><br><span class="line">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line">#全局级：对所有的会话有效 </span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><p>​    查看隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation</span><br></pre></td></tr></table></figure><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h4><p>​    即在修改表（增、删、改）时触发相应的SQL语句。<strong>注：</strong> 不能用在临时表和视图上，尽量少使用触发器，不建议使用，因为它十分消耗资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#创建触发器</span><br><span class="line">create trigger triggerName</span><br><span class="line">after/before insert/delete/update </span><br><span class="line">on tableName</span><br><span class="line">for each row</span><br><span class="line">sql;   #触发SQL语句</span><br><span class="line"></span><br><span class="line">#删除触发器</span><br><span class="line">drop trigger triggerName;</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h4><p>​        提高查询速度,但是 <strong>降低</strong> 了<strong>增删改</strong>的速度，所以使用索引时,要综合考虑，<strong>索引不是越多越好</strong>，一般我们在<strong>经常</strong>出现于条件表达式中的列加索引，值越分散的列，索引的效果越好。</p><p>​    <strong>索引类型：</strong><code>primary key</code>主键索引、<code>index</code> 普通索引、<code>unique index</code> 唯一性索引、<code>fulltext index</code> 全文索引</p><p>​    在这儿再贴上之前提过的创建和删除语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#增加索引</span><br><span class="line">alter table tableName add [unique|fulltext] index 索引名(列名);</span><br><span class="line">#删除索引</span><br><span class="line">alter table tableName drop index 索引名;</span><br></pre></td></tr></table></figure><p><strong>参考文章：</strong></p><blockquote><p>mysql：<a href="https://blog.poetries.top/2019/01/22/mysql-base-review/" target="_blank" rel="noopener">https://blog.poetries.top/2019/01/22/mysql-base-review/</a></p><p>分组查询：<a href="https://zhuanlan.zhihu.com/p/46925457" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46925457</a></p><p>事务：<a href="https://blog.csdn.net/w_linux/article/details/79666086" target="_blank" rel="noopener">https://blog.csdn.net/w_linux/article/details/79666086</a></p><p>触发器：<a href="https://www.cnblogs.com/geaozhang/p/6819648.html" target="_blank" rel="noopener">https://www.cnblogs.com/geaozhang/p/6819648.html</a></p><p>索引：<a href="https://zhuanlan.zhihu.com/p/29118331" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29118331</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="MySQL" scheme="https://www.ipyker.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="https://www.ipyker.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>&#39;2017-EMNLP-Deep Joint Entity Disambiguation with Local Neural Attention&#39;</title>
    <link href="https://www.ipyker.com/2020/02/26/Attention.html"/>
    <id>https://www.ipyker.com/2020/02/26/Attention.html</id>
    <published>2020-02-26T01:27:22.000Z</published>
    <updated>2020-03-01T01:39:33.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>​    我们提出了一种新的文档级别联合实体消歧的深度学习模型，关键部分有实体嵌入、基于上下文窗格的神经注意力机制和a differentiable joint inference stage for disambiguation 。<a id="more"></a>我们的方法因而结合了深度学习和大多数传统方法（如图模型和概率图等等）的优点。实验显示在适度的计算代价内我们能够获得stateof-the-art 的准确率。</p><h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><p>​    实体消歧（ED）在给出的知识库（KB ）中解决了涉及到的实体问题，是文本理解的一个重要阶段，ED任务因为内在含义的模糊性（如实体名和实体本身代表的含义）而极具挑战力。这种多对多的不确定能够被从实体链接语料库中提取出的name-entity co-occurrence counts 部分捕获。</p><p>​    ED的研究大部分专注于两种文本信息的消歧：一是局部信息，只是这些实体提到的文本上下文窗格大小范围内的词；而全局信息，是开发相关实体的文档 coherence ，很多stateof-the-art 的方法旨在结合这两者的好处，而这也是我们所遵守的哲理。我们方法的特殊之处在于我们用实体嵌入做了通用表现来同时评估局部和全局。</p><p>​    这些年，很多文本和语言理解任务都是利用神经网络架构进行升级。然而，尽管是在最近的工作中，有竞争性的ED系统仍然大量地使用了人工设计的特征。这些特征总是依赖于领域知识，而且很多统计相关的依赖关系和相互作用是失败的。我们的工作有一个明确的目标，就是利用深度学习从scratch 中学习基本特征和它们的组合。穷尽我们的知识，伴随严苛，我们第一个采取了这个计划。</p><h4 id="2-Contributions-and-Related-Work"><a href="#2-Contributions-and-Related-Work" class="headerlink" title="2 Contributions and Related Work"></a>2 Contributions and Related Work</h4><p>​    之前在实体消歧方面就有大量的研究，尤其是(Ji, 2016  Entity discovery and linking reading list. ) ，我们将在这里讨论之前相关研究工作中的主要贡献。</p><h5 id="Entity-Embeddings"><a href="#Entity-Embeddings" class="headerlink" title="Entity Embeddings."></a>Entity Embeddings.</h5><p>​    我们在向量空间中已经发现了一种简单却高效的方法来做实体嵌入和词嵌入。这是鉴于词嵌入e.g. (Mikolov et al., 2013; Pennington et al.,2014)， 后来被拓展到实体嵌入和ED(Yamada et al., 2016; Fang et al., 2016;Zwicklbauer et al., 2016; Huang et al., 2015) 。和上面的方法需求数据的entity-entity co-occurrences 通常都很稀疏不同，我们宁可提升词嵌入从它们的典型实体页面和它们的超链接注释的局部上下文。这让训练更高效而且减轻了compile co-linking statistics 的需求。这些向量表现是避免手工设计特征、多重的消歧步骤、ED任务中对额外启发式算法的需求的关键。</p><h5 id="Context-Attention"><a href="#Context-Attention" class="headerlink" title="Context Attention."></a>Context Attention.</h5><p>​    我们为局部ED提出了一种新的注意力机制。受记忆网络(Sukhbaatar et al., 2015)  和(Lazic et al.,2015) 的启发，我们的模型部署了注意力机制来选择那些对消歧提供有用信息的词语。是一个结合了情境实体分数和记忆实体最终分数的学习。我们的局部模型获得了更好的精确率相比于局部概率模型(Ganeaet al., 2016) 和基于特征工程的局部模型(Globerson et al., 2016)。作为新特点，我们的模型拥有更小的内存占用并且能快速完成训练和测试。</p><p>​    </p><p>​    未完待续。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;p&gt;​    我们提出了一种新的文档级别联合实体消歧的深度学习模型，关键部分有实体嵌入、基于上下文窗格的神经注意力机制和a differentiable joint inference stage for disambiguation 。
    
    </summary>
    
      <category term="Translates" scheme="https://www.ipyker.com/categories/Translates/"/>
    
    
      <category term="translating" scheme="https://www.ipyker.com/tags/translating/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Cypher&#39;</title>
    <link href="https://www.ipyker.com/2020/02/24/Cypher.html"/>
    <id>https://www.ipyker.com/2020/02/24/Cypher.html</id>
    <published>2020-02-24T01:00:00.000Z</published>
    <updated>2020-03-01T01:38:47.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Cypher"><a href="#Cypher" class="headerlink" title="Cypher"></a>Cypher</h2><p>​    一种 <strong>Neo4j</strong> 的查询语言，她是根据查询的路径来进行编写。</p><p>​    举栗子：<em>a Person</em> <code>LIVES_IN</code> <em>a City</em> or <em>a City is</em> <code>PART_OF</code> <em>a Country</em>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(:Person) -[:LIVES_IN]-&gt; (:City) -[:PART_OF]-&gt; (:Country)</span><br></pre></td></tr></table></figure><h4 id="node-syntax"><a href="#node-syntax" class="headerlink" title="node syntax"></a>node syntax</h4><p> () 代表任何节点，包罗万象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">()  </span><br><span class="line">(matrix)</span><br><span class="line">(:Movie)</span><br><span class="line">(matrix:Movie)</span><br><span class="line">(matrix:Movie &#123;title: &quot;The Matrix&quot;&#125;)</span><br><span class="line">(matrix:Movie &#123;title: &quot;The Matrix&quot;, released: 1997&#125;)</span><br></pre></td></tr></table></figure><h4 id="relationship-syntax"><a href="#relationship-syntax" class="headerlink" title="relationship syntax"></a>relationship syntax</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--&gt;</span><br><span class="line">-[role]-&gt;</span><br><span class="line">-[:ACTED_IN]-&gt;</span><br><span class="line">-[role:ACTED_IN]-&gt;</span><br><span class="line">-[role:ACTED_IN &#123;roles: [&quot;Neo&quot;]&#125;]-&gt;</span><br></pre></td></tr></table></figure><h4 id="pattern-syntax"><a href="#pattern-syntax" class="headerlink" title="pattern syntax"></a>pattern syntax</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(keanu:Person:Actor &#123;name:  &quot;Keanu Reeves&quot;&#125; )</span><br><span class="line">-[role:ACTED_IN     &#123;roles: [&quot;Neo&quot;] &#125; ]-&gt;</span><br><span class="line">(matrix:Movie       &#123;title: &quot;The Matrix&quot;&#125; )</span><br></pre></td></tr></table></figure><p>‘ <strong>:</strong> ‘之前的均为变量，为了方便在别的地方进行引用，</p><p>当然，变量也可以用来表示一条路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acted_in = (:Person)-[:ACTED_IN]-&gt;(:Movie)</span><br></pre></td></tr></table></figure><p>路径也有一些属性，如节点数，关系数和路径长度，<code>nodes(path)</code>, <code>relationships(path)</code> ,<code>length(path)</code>.</p><h4 id="clauses"><a href="#clauses" class="headerlink" title="clauses"></a>clauses</h4><p>​     CREATE  ONE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)</span><br></pre></td></tr></table></figure><p>​    CREATE  MORE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE (a:Person &#123; name:&quot;Tom Hanks&quot;,</span><br><span class="line">  born:1956 &#125;)-[r:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(m:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)</span><br><span class="line">CREATE (d:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)-[:DIRECTED]-&gt;(m)</span><br><span class="line">RETURN a,d,r,m</span><br></pre></td></tr></table></figure><p>  MATCH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (m:Movie)</span><br><span class="line">RETURN m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123; name:&quot;Keanu Reeves&quot; &#125;)</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)-[r:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">RETURN m.title, r.roles</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)</span><br><span class="line">CREATE (m:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)</span><br><span class="line">CREATE (p)-[r:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(m)</span><br><span class="line">RETURN p,r,m</span><br></pre></td></tr></table></figure><p>  MERGE（MATCH+CREATE）</p><p>  先判断需要玩弄的东西在数据库中是否存在，再进行相应的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MERGE (m:Movie &#123; title:&quot;Cloud Atlas&quot; &#125;)</span><br><span class="line">ON CREATE SET m.released = 2012</span><br><span class="line">RETURN m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATCH (m:Movie &#123; title:&quot;Cloud Atlas&quot; &#125;)</span><br><span class="line">MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)</span><br><span class="line">MERGE (p)-[r:ACTED_IN]-&gt;(m)</span><br><span class="line">ON CREATE SET r.roles =[&apos;Zachry&apos;]</span><br><span class="line">RETURN p,r,m</span><br></pre></td></tr></table></figure><p>  如果没有满足MERGE之后描述的关系，就执行相应的操作（创建一个2014Year）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE (y:Year &#123; year:2014 &#125;)</span><br><span class="line">MERGE (y)&lt;-[:IN_YEAR]-(m10:Month &#123; month:10 &#125;)</span><br><span class="line">MERGE (y)&lt;-[:IN_YEAR]-(m11:Month &#123; month:11 &#125;)</span><br><span class="line">RETURN y,m10,m11</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5e553e7d6127cc0713b0d0f7.png" alt="neo4j03"></p><h2 id="Getting-the-correct-results"><a href="#Getting-the-correct-results" class="headerlink" title="Getting the correct results"></a>Getting the correct results</h2><p>  一个官方实例，首先创建用于练习的图。该图包含电影和人物节点，参演（属性有角色roles，即参演的演员）和指导关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE (matrix:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)</span><br><span class="line">CREATE (cloudAtlas:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)</span><br><span class="line">CREATE (forrestGump:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)</span><br><span class="line">CREATE (keanu:Person &#123; name:&quot;Keanu Reeves&quot;, born:1964 &#125;)</span><br><span class="line">CREATE (robert:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)</span><br><span class="line">CREATE (tom:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)</span><br><span class="line">CREATE (tom)-[:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(forrestGump)</span><br><span class="line">CREATE (tom)-[:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(cloudAtlas)</span><br><span class="line">CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</span><br></pre></td></tr></table></figure><p>  查找标题为”The Matrix”的电影</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (m:Movie)</span><br><span class="line">WHERE m.title = &quot;The Matrix&quot;</span><br><span class="line">RETURN m</span><br></pre></td></tr></table></figure><p>  上条查询语句也可以直接写成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (m:Movie &#123; title: &quot;The Matrix&quot; &#125;)</span><br><span class="line">RETURN m</span><br></pre></td></tr></table></figure><p>  Cypher中  ‘ <strong>=~</strong> ‘ 表示进行正则匹配</p><p>  查询 p-r-&gt;m，人物名字为’k’开头 or 电影在2000年后发行  or  参演的角色中包含 “Neo”，返回满足以上条件的 p,r,m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE p.name =~ &quot;K.+&quot; OR m.released &gt; 2000 OR &quot;Neo&quot; IN r.roles</span><br><span class="line">RETURN p,r,m</span><br></pre></td></tr></table></figure><p>  查询p-&gt;m 且 p 没有指导任何电影，返回p,m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;(m)</span><br><span class="line">WHERE NOT (p)-[:DIRECTED]-&gt;()</span><br><span class="line">RETURN p,m</span><br></pre></td></tr></table></figure><p>  上述例子都是直接返回变量，接下来看看返回numbers, strings, arrays，maps 的情况。</p><p>  ‘ <strong>coalesce()</strong> ’ 返回第一个非空值，当所有的都为空时，则返回null,</p><p>下例中则表示若p没有昵称则直接返回”n/a”，更一般的，对于coalesce(a,b)，若a , b均为空值，则返回null。</p><p>  ‘ <strong>AS</strong> ‘ 表示 为一个东西起别名，是返回的表中的列名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)</span><br><span class="line">RETURN p, p.name AS name, toUpper(p.name), coalesce(p.nickname,&quot;n/a&quot;) AS nickname,</span><br><span class="line">  &#123; name: p.name, label:head(labels(p))&#125; AS person</span><br></pre></td></tr></table></figure><p>  ‘ <strong>DISTINCT</strong> ‘ ，用于去重，即返回唯一值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n)</span><br><span class="line">RETURN DISTINCT labels(n) AS Labels</span><br></pre></td></tr></table></figure><p>  返回总人数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (:Person)</span><br><span class="line">RETURN count(*) AS people</span><br></pre></td></tr></table></figure><p>  Cypher也支持聚集函数，如<code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code></p><p>  返回 <strong>共同满足</strong> 参演关系和指导关系的人物和总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (actor:Person)-[:ACTED_IN]-&gt;(movie:Movie)&lt;-[:DIRECTED]-(director:Person)</span><br><span class="line">RETURN actor, director, count(*) AS collaborations</span><br></pre></td></tr></table></figure><p>  对结果进行排序，分页 <code>SKIP {offset}</code>、 <code>LIMIT {count}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (a:Person)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">RETURN a, count(*) AS appearances</span><br><span class="line">ORDER BY appearances DESC LIMIT 10;</span><br></pre></td></tr></table></figure><p>  ‘ <strong>collect()</strong> ‘把返回的多个值或记录组装成一个列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (m:Movie)&lt;-[:ACTED_IN]-(a:Person)</span><br><span class="line">RETURN m.title AS movie, collect(a.name) AS cast, count(*) AS actors</span><br></pre></td></tr></table></figure><p>  ‘ <strong>UNWIND</strong> ‘ 拆解collect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNWIND[1,2,3] AS x</span><br><span class="line">RETURN x</span><br></pre></td></tr></table></figure><h2 id="Composing-large-statements"><a href="#Composing-large-statements" class="headerlink" title="Composing large statements"></a>Composing large statements</h2><p>  使用的例子图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE (matrix:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)</span><br><span class="line">CREATE (cloudAtlas:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)</span><br><span class="line">CREATE (forrestGump:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)</span><br><span class="line">CREATE (keanu:Person &#123; name:&quot;Keanu Reeves&quot;, born:1964 &#125;)</span><br><span class="line">CREATE (robert:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)</span><br><span class="line">CREATE (tom:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)</span><br><span class="line">CREATE (tom)-[:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(forrestGump)</span><br><span class="line">CREATE (tom)-[:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(cloudAtlas)</span><br><span class="line">CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title=" "></a> </h5><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><p>  对于相似的查询结构，取结果的并集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATCH (actor:Person)-[r:ACTED_IN]-&gt;(movie:Movie)</span><br><span class="line">RETURN actor.name AS name, type(r) AS type, movie.title AS title</span><br><span class="line">UNION</span><br><span class="line">MATCH (director:Person)-[r:DIRECTED]-&gt;(movie:Movie)</span><br><span class="line">RETURN director.name AS name, type(r) AS type, movie.title AS title</span><br></pre></td></tr></table></figure><p>  以上语句等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (actor:Person)-[r:ACTED_IN|DIRECTED]-&gt;(movie:Movie)</span><br><span class="line">RETURN actor.name AS name, type(r) AS type, movie.title AS title</span><br></pre></td></tr></table></figure><h4 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h4><p>  引导数据的流向，和 <strong>RETURN</strong> 相似只是不会终止查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (person:Person)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WITH person, count(*) AS appearances, collect(m.title) AS movies</span><br><span class="line">WHERE appearances &gt; 1</span><br><span class="line">RETURN person.name, appearances, movies</span><br></pre></td></tr></table></figure><h2 id="Defining-a-schema"><a href="#Defining-a-schema" class="headerlink" title="Defining a schema"></a>Defining a schema</h2><p>  例子图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE (matrix:Movie &#123; title:&quot;The Matrix&quot;,released:1997 &#125;)</span><br><span class="line">CREATE (cloudAtlas:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)</span><br><span class="line">CREATE (forrestGump:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)</span><br><span class="line">CREATE (keanu:Person &#123; name:&quot;Keanu Reeves&quot;&#125;)</span><br><span class="line">CREATE (robert:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)</span><br><span class="line">CREATE (tom:Person &#123; name:&quot;Tom Hanks&quot;, born:1956 &#125;)</span><br><span class="line">CREATE (tom)-[:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(forrestGump)</span><br><span class="line">CREATE (tom)-[:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(cloudAtlas)</span><br><span class="line">CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</span><br></pre></td></tr></table></figure><h4 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h4><p>  创建索引，这样在查询的时候会加快查询速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX ON :Actor(name)</span><br></pre></td></tr></table></figure><p>  查看数据库中的索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL db.indexes</span><br><span class="line">YIELD description, tokenNames, properties, type;</span><br></pre></td></tr></table></figure><h4 id="CONSTRAINT"><a href="#CONSTRAINT" class="headerlink" title="CONSTRAINT"></a>CONSTRAINT</h4><p>  为数据添加需要遵守的相关规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE</span><br></pre></td></tr></table></figure><p>  查看constraints。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL db.constraints</span><br></pre></td></tr></table></figure><h2 id="Import-data"><a href="#Import-data" class="headerlink" title="Import data"></a>Import data</h2><p>  我们要导入movies.csv，roles.csv，persons.csv三个文件到图数据库中。假如文件都使用<code>file:///</code> URL。</p><p>  1、首先为我们的电影和人物的ID创建唯一约束，为城市名创建索引就隐含了唯一的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONSTRAINT ON (person:Person) ASSERT person.id IS UNIQUE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.id IS UNIQUE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX ON :Country(name)</span><br></pre></td></tr></table></figure><p>  2、然后我们将文件加载进来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///persons.csv&quot; AS csvLine</span><br><span class="line">CREATE (p:Person &#123;id: toInteger(csvLine.id), name: csvLine.name&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///movies.csv&quot; AS csvLine</span><br><span class="line">MERGE (country:Country &#123;name: csvLine.country&#125;)</span><br><span class="line">CREATE (movie:Movie &#123;id: toInteger(csvLine.id), title: csvLine.title, year:toInteger(csvLine.year)&#125;)</span><br><span class="line">CREATE (movie)-[:MADE_IN]-&gt;(country)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USING PERIODIC COMMIT 500  //大文件进行分批导入，默认1000行提交一次，这里设置为500行提交一次</span><br><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:///roles.csv&quot; AS csvLine</span><br><span class="line">MATCH (person:Person &#123;id: toInteger(csvLine.personId)&#125;),(movie:Movie &#123;id: toInteger(csvLine.movieId)&#125;)</span><br><span class="line">CREATE (person)-[:PLAYED &#123;role: csvLine.role&#125;]-&gt;(movie)</span><br></pre></td></tr></table></figure><p>  3、最后删除我们创建的唯一约束</p><p>  小伙伴疑惑了，为什么要删除呢？因为ID的目的仅仅是为了便于导入关系的，最后我们当然可以进行删除啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP CONSTRAINT ON (person:Person) ASSERT person.id IS UNIQUE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP CONSTRAINT ON (movie:Movie) ASSERT movie.id IS UNIQUE</span><br></pre></td></tr></table></figure><p>参考文档：</p><blockquote><p><a href="https://neo4j.com/docs/getting-started/current/cypher-intro/results/" target="_blank" rel="noopener">https://neo4j.com/docs/getting-started/current/cypher-intro/results/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Neo4j" scheme="https://www.ipyker.com/categories/Neo4j/"/>
    
    
      <category term="cypher" scheme="https://www.ipyker.com/tags/cypher/"/>
    
  </entry>
  
  <entry>
    <title>&#39;初识Neo4j&#39;</title>
    <link href="https://www.ipyker.com/2020/02/23/%E5%88%9D%E8%AF%86Neo4j.html"/>
    <id>https://www.ipyker.com/2020/02/23/初识Neo4j.html</id>
    <published>2020-02-23T01:26:25.000Z</published>
    <updated>2020-03-01T01:40:06.188Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Neo4j‘s-GOOD"><a href="#Neo4j‘s-GOOD" class="headerlink" title="Neo4j‘s GOOD"></a>Neo4j‘s GOOD</h3><ul><li><p>完整的ACID支持（保证了<strong>数据的一致性</strong>）</p></li><li><p>高可用性</p><p>可以非常轻松地集成到任何一个应用，只会受到计算机本身硬件性能的影响，而不会不受业务本身的约束。</p></li><li><p>轻易扩展到上亿级别的节点和关系</p></li><li><p>通过遍历工具高速检索数据</p></li></ul><h3 id="WHAT-图数据库"><a href="#WHAT-图数据库" class="headerlink" title="WHAT 图数据库?"></a>WHAT 图数据库?</h3><p>​    1、图数据库用图来存储数据，是最接近高性能的一种用于存储数据的数据结构方式之一。</p><p>​    2、一个图由无数的节点和关系组成，关系将图各个部分组织起来。如： 小黄拥有小韩，小韩喜欢小猪，这只小猪它是粉红色的（你知道吗小黄会嫉妒这只小猪的  …），粉红色就是这只猪的属性了。</p><p><img src="https://pic.downk.cc/item/5e552add6127cc0713ad184f.png" alt="neo4j01"></p><p>​    3、用 Traversal 进行数据库查询，通过一种算法（宽度优先或深度优先），从一些开始节点开始查询与其关联的节点，经过一条路径最终找到结果。小黄—&gt;小韩—&gt;小猪</p><p>​    4、为节点和关系建立索引，这样可以更高效地进行查询。如： 我要查询的人名字叫 <strong>韩小沐</strong>（敲黑板，故事发展的重要人物。）</p><p>​            <img src="https://pic.downk.cc/item/5e552d8d6127cc0713ad8d9a.png" alt="neo4j02"></p><p>​    5、标签，为了便于进行特定的操作。如为小韩贴上 <strong>nicer</strong> 标签，就能更方便的使用，一个实体可以贴上多个标签，可以再给小韩贴上 <strong>student</strong> 标签，这样她就不可以恋爱啦，哈哈。</p><p>​    最后让我们来看一下推荐的节点，关系，属性命名规则吧：</p><p>​        节点： <code>:VehicleOwner</code> rather than <code>:vehice_owner</code></p><p>​        关系： <code>:OWNS_VEHICLE</code> rather than <code>:ownsVehicle</code></p><p>​        属性： <code>firstName</code> rather than <code>first_name</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Neo4j" scheme="https://www.ipyker.com/categories/Neo4j/"/>
    
    
      <category term="neo4j" scheme="https://www.ipyker.com/tags/neo4j/"/>
    
  </entry>
  
</feed>
